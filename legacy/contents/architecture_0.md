# Clean Architecture

우리는 많은 프로젝트를 시작하고 유지 보수하고 배포하고 있습니다. 한 번에 여러 개의 프로젝트를 담당할 수 있고 한 프로젝트에서 일부 기능을 담당할 수도 있습니다. 또는 갑자기 다른 프로젝트를 인수인계받거나 프로젝트를 떠나서 인수인계를 해주어야 할 상황이 생길 수 있습니다. 우리는 우리의 프로젝트를 가장 잘 이해하고 있어야 하며 잘 설명할 수 있어야 합니다.

현재 많은 개인, 팀, 기업들이 소프트웨어를 개발할 때 클린 아키텍처를 도입하고 적용하고 있습니다. 클린 아키텍처를 공부해야 하는 이유가 여러 가지 있겠지만 제가 생각하는 가장 큰 이유는 이미 클린 아키텍처가 적용된 많은 프로젝트를 새롭게 맞이하게 될 때 조금이라도 더 빠르게 구조를 파악하고 이해하는 것에 있다고 생각합니다. 또한 새로 프로젝트를 받아보게 될 사람에게 이해시키기 위해서도 필요합니다. 서로 클린 아키텍처에 대한 이해도가 있다고 한다면 이야기가 쉽게 풀어질 것입니다.

## 1. 클린 아키텍처의 등장

2012년 `The Clean Code Blog`에 `Robert C. Martin(Uncle Bob)`이 [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)란 게시글을 올렸습니다. 모든 범위에서 견고하고 지속 가능한 소프트웨어를 개발할 때 시스템 아키텍처를 어떻게 구현해야 하는지 고민하고 많은 아이디어를 정리한 글이었습니다. 이 글은 많은 개발자들에게 공감을 받았고 많은 분야에서 해당 내용을 적용해 보고자 하였습니다. 그 결과 각 분야에 맞게 변형하고 적용된 프로젝트들이 많아지게 되었고 이제는 보편적인 개념이 되었습니다.

## 2. 클린 아키텍처의 개념

클린 아키텍처에서 핵심 개념은 `관심사 분리`입니다. 클린 아키텍처에서는 크게 4가지 계층으로 나누어서 관심사를 분리하고 있습니다. 물론 3가지, 5가지 등 다른 방식으로 계층을 나누어도 됩니다. 단지 반드시 지켜야 하는 개념은 각 계층에서 다른 계층으로의 관심사를 분리하는 것입니다.

프로그램을 작성하다 보면 서로의 클래스들이 종속성을 이루고 있습니다. A클래스에서 B클래스 혹은 서로 엮인 경우도 심심치 않게 보이곤 합니다. 이런 경우 서로에게 종속성을 가지게 되고 소스가 수정되면 서로에게 영향을 미치게 됩니다. 이렇게 되면 유지보수가 힘들게 되고 테스트가 힘들어지게 됩니다. 흔히 말하는 한 곳을 수정하면 다른 곳에서 에러가 발생해서 에러 추적도 힘들게 되는 스파게티 코드가 됩니다. 그래서 우리는 각 클래스의 관심사를 분리해서 종속성을 제거하고 의존성을 낮추는 방식의 구조인 클린 아키텍처를 도입하게 됩니다.

클린 아키텍처는 아래와 같이 크게 4가지 계층으로 나뉘게 됩니다. 화살표 방향으로 의존성을 가지고 반대 방향으로는 의존성을 가지지 않게 합니다. 각 계층은 철저하게 각 계층에서 구현되며 외부(화살표 반대 방향) 계층에서 사용할 수 있는 Interface를 제공합니다. 내부 계층은 외부 계층을 이용해서 구현해서는 안 됩니다. 외부 계층은 내부 계층을 Interface를 통해서 사용하지만 어떤 방식으로 구현되어있는지 알지 못합니다.

<img src="../resource/the_clean_architecture.jpeg" />

요약하자면,

1. 각 계층은 계층 안에서 구현되어야 한다.
2. 내부 계층은 외부 계층의 기능을 사용하지 못한다.
3. 내부 계층은 외부 계층에서 사용할 수 있는 Interface를 제공한다.
4. 외부 계층은 내부 계층의 기능을 Interface를 통해 사용할 수 있다.

## 3. 클린 아키텍처의 구현

### Enterprise Business Rules (Entities)

Entities 계층은 개발하고자 하는 소프트웨어의 코어 비즈니스 규칙을 캡슐화합니다. Entity는 비즈니스 규칙을 구현한 클래스이거나 비즈니스 규칙을 표현하는 데이터와 함수를 가지는 클래스입니다. Entity는 외부의 변화에 수정되어서는 안 되므로 구현할 때 일반적이고 고수준의 규칙을 캡슐화해야 합니다.

예를 들어, 운영상의 변경이나 보안 변경, 페이지 탐색 등 외부 요인이 변한다고 해서 Entities 계층에 영향이 미쳐서는 안 됩니다.

### Application Buisiness Rules (Use Cases)

Use Cases 계층에서는 개발하고자 하는 소프트웨어의 모든 사용 사례를 캡슐화하고 구현합니다. Use Case는 Entity 간의 데이터 흐름을 조정하고 해당 Entity는 Use Case에 규칙을 사용할 수 있도록 기능을 제공해야 합니다.

Use Cases 계층의 변경 사항이 Entities 계층에 영향이 미쳐서는 안 됩니다. 또한 UI, Database, Frameworks와 같은 외부 요소의 변경에 영향을 받지 않아야 합니다.

### Interface Adapters (Presenters, Conterollers, etc...)

Interface Adapters 계층은 앞서 구현한 Use Case, Entity로 받은 형식에서 데이터베이스 또는 웹과 같은 외부 계층에게 가장 편리한 형식으로 데이터를 변환해주는 Interface Adapter를 구현합니다. 또한 데이터를 외부 계층 형식에서 내부 계층 형식으로 변환하는 클래스가 포함됩니다.

예를 들어, GUI의 MVP 아키텍처가 포함됩니다. Model은 Controller에서 Use Cases 계층으로 전달된 다음 Use Cases 계층에서 Presenter로 전달되는 구조입니다.

### Frameworks & Drivers (DB, Deivces, Exteral Interfaces, etc...)

이 계층에는 모든 세부 사항이 구현됩니다. 일반적으로 데이터베이스, 웹 프레임워크와 도구들로 구성됩니다. 웹은 UI, 데이터베이스는 세부 사항이며 이러한 구현이 내부 계층에 영향을 미쳐서는 안 됩니다.

## 4. 클린 아키텍처의 이점

클린 아키텍처에서 가장 중요한 개념은 관심사를 분리하여 종속성을 제거하고 의존성을 낮추는 것입니다. 소프트웨어를 각 계층으로 나누고 종속성 규칙을 지키면 많은 이점이 있습니다.

1. 계층별로 구현하고자 하는 내용이 다르기 때문에 구조 파악을 빠르게 할 수 있다.
2. 캡슐화가 되어있어 외부 요인에 의한 변경이 쉽다.
3. 각 기능 간 의존성이 줄어들어 기능을 테스트하기 쉽다.
4. 소스를 수정해도 외부에 영향이 적어 효과적으로 유지보수할 수 있다.
5. 이미 구현된 내용의 조합으로 새로운 기능을 빠르게 개발할 수 있다.
6. 구조화된 프로젝트 관리로 협업에 유리하다.
